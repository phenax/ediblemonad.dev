"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[295],{6295:function(e,s,n){n.r(s),n.d(s,{meta:function(){return r}});var l=n(1527),a=n(6736);let r={title:"Designing effects as data structures",description:"Dipping our feet into the world of effect handlers to design composition of our effects as a data-structure with free monads",published:!0,date:"2021-03-01"};function i(e){let s=Object.assign({p:"p",hr:"hr",h2:"h2",pre:"pre",code:"code",span:"span",strong:"strong",a:"a",em:"em",blockquote:"blockquote",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.p,{children:"You gotta teach your effects some manners."}),"\n",(0,l.jsx)(s.p,{children:"We work with effects everyday, but those rascals have a habit of running around loose in our programs.\nI'm not saying it's just bad parenting but we have to draw the line at some point."}),"\n",(0,l.jsx)(s.p,{children:"Look at pure functions, they are so disciplined and obedient. They never get into any trouble.\nYou ask them a question, they give you an answer. That's what you expect from good code.\nIf you find out that your function, while giving you the answer, also went ahead and made 5 api calls, thats a good sign that your code needs some disciplining."}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Let's implement a linked list"}),"\n",(0,l.jsx)(s.p,{children:"I swear this is relevant and not a plot to make you learn DSA again."}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," myList<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"})," | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),", myList<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">)\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ls = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-number",children:"5"}),", ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-number",children:"20"}),", ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(-",(0,l.jsx)(s.span,{className:"hljs-number",children:"28"}),", ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"}),")))\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["That is a simple ",(0,l.jsx)(s.strong,{children:"linked list"})," implemented in ",(0,l.jsx)(s.a,{href:"https://rescript-lang.org/",children:"rescript"}),".\n",(0,l.jsx)(s.code,{children:"Nil"})," marks the end of the list and every element before it contains an item of that list and the rest of the list.\nThey know how to stand in a straight line like good students."]}),"\n",(0,l.jsxs)(s.p,{children:["But, this is an ",(0,l.jsx)(s.strong,{children:"eager list"})," since all items of the list already exist on the time of its creation. For what we're working on today, eager lists won't be enough. We need our list to be ",(0,l.jsx)(s.em,{children:"lazy"}),".\nWe can turn that into a ",(0,l.jsx)(s.strong,{children:"lazy linked list"})," by replacing the rest of the list with a function returning the rest of the list like so -"]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," lazyList<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"})," | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"unit"})," => lazyList<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">)\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ls = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-number",children:"5"}),", ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"})," =>\n  ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-number",children:"20"}),", ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"})," =>\n    ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(",(0,l.jsx)(s.span,{className:"hljs-number",children:"512"}),", ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"})," =>\n      ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"}),")))\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["This makes it so the rest of the linked list doesn't exist till the function is called.\nThis is helpful if you wanted to create an ",(0,l.jsx)(s.strong,{children:"infinite list"}),"."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," fibonacci = (a, b) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(b, ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"})," => fibonacci(b, a",(0,l.jsx)(s.span,{className:"hljs-operator",children:" + "}),"b))\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," take = (ls, n) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," (n, ls) {\n  | (_, ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"}),") | (",(0,l.jsx)(s.span,{className:"hljs-number",children:"0"}),", _) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"}),"\n  | (n, ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(value, next)) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(value, ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"})," => next",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),"->take(n - ",(0,l.jsx)(s.span,{className:"hljs-number",children:"1"}),"))\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," forEach = (ls, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," ls {\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Nil"})," => ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),"\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Cons"}),"(value, next) => {\n    fn(value)\n    next",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),"->forEach(fn)\n  }\n}\n\nfibonacci(",(0,l.jsx)(s.span,{className:"hljs-number",children:"0"}),", ",(0,l.jsx)(s.span,{className:"hljs-number",children:"1"}),")->take(",(0,l.jsx)(s.span,{className:"hljs-number",children:"20"}),")->forEach(",(0,l.jsx)(s.span,{className:"hljs-type",children:"Js"}),".log)\n"]})}),"\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.code,{children:"fibonacci"})," returns a lazy list of all the numbers in Fibonacci series starting with ",(0,l.jsx)(s.code,{children:"a"})," and ",(0,l.jsx)(s.code,{children:"b"}),". We then use the ",(0,l.jsx)(s.code,{children:"take"})," function to ignore the list after the first ",(0,l.jsx)(s.code,{children:"20"})," items. ",(0,l.jsx)(s.code,{children:"forEach"}),", then goes through the new list till the 20 items and logs each one out."]}),"\n",(0,l.jsxs)(s.p,{children:["This is very helpful for ",(0,l.jsx)(s.strong,{children:"modeling continuous sequences"})," of data without consuming all the space it may need."]}),"\n",(0,l.jsxs)(s.p,{children:["Everything we've played with so far has been ",(0,l.jsx)(s.em,{children:"simple"})," and ",(0,l.jsx)(s.em,{children:"pure"}),". Unlike those disobedient effects passing notes to each other, non-deterministically. Oh I hate them so much."]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Can effects be more like that?"}),"\n",(0,l.jsxs)(s.p,{children:["Close your eyes. No, seriously, close them. This is important.\nNow, imagine a world where all your effectful code could just be designed as ",(0,l.jsx)(s.em,{children:"data structures"}),"!\nAre your eyes still closed? Good.\nSomething as simple as a linked list that describes all the effectful logic in your code.\nWriting tests will become fun!\nEverything would be so much simpler. All of our life's problems would just disappear."]}),"\n",(0,l.jsx)(s.p,{children:"Well, today's yo... Oh you can open your eyes now. Sorry.\nWell, today's your lucky day!"}),"\n",(0,l.jsx)(s.p,{children:"We will turn your ill-mannered effects into well behaved pure data structures."}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Impure effect? More like code neglect, amirite? Please clap"}),"\n",(0,l.jsxs)(s.p,{children:["Kids, please turn in your assignment from last week. I hope you all implemented ",(0,l.jsx)(s.code,{children:"appendStringToFile: string => string => string"})," that appends a string to a file and returns the new contents, given the imaginary synchronous functions ",(0,l.jsx)(s.code,{children:"readFile: string => string"})," and ",(0,l.jsx)(s.code,{children:"writeFile: string => string => ()"})," for doing file IO."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," appendStringToFile = (fileName, logLine) => {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," contents = readFile(fileName)\n  writeFile(contents",(0,l.jsx)(s.span,{className:"hljs-operator",children:" ++ "}),"logLine)\n  readFile(fileName)\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," newLogContents = appendStringToFile(fileName, ",(0,l.jsx)(s.span,{className:"hljs-string",children:'"\\nSome text"'}),")\n"]})}),"\n",(0,l.jsx)(s.p,{children:"Oh my god, Timmy! Is that imperative and impure function calls in your notebook? That's it. To the principals office! Now!"}),"\n",(0,l.jsx)(s.p,{children:"Now let's try to think of a way to do this that's not an absolute nightmare to test.\nWhat if we just made a data structure out of it?"}),"\n",(0,l.jsx)(s.p,{children:"Let's try turning each of those statements into variants that can be linked together lazily."}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," fileEff<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> =\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"})," => fileEff<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">)\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"unit"})," => fileEff<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">)\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),")\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," appendStringToFile = (fileName, logLine) =>\n  ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, contents =>\n    ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(fileName, contents",(0,l.jsx)(s.span,{className:"hljs-operator",children:" ++ "}),"logLine, _ =>\n      ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, newContents =>\n        ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(newContents))))\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["You can read ",(0,l.jsx)(s.code,{children:"Something(a, b, c => fileEff<'a>)"})," as an operation ",(0,l.jsx)(s.code,{children:"Something"})," that takes ",(0,l.jsx)(s.code,{children:"a"})," and ",(0,l.jsx)(s.code,{children:"b"})," and returns a ",(0,l.jsx)(s.code,{children:"c"}),"."]}),"\n",(0,l.jsxs)(s.p,{children:["If you squint hard enough, you'll find that this is very similar to the ",(0,l.jsx)(s.strong,{children:"lazy list"})," data structure we implemented earlier.\nYou have the last item ",(0,l.jsx)(s.code,{children:"Return"}),", and each item before it is a description of an effect."]}),"\n",(0,l.jsxs)(s.p,{children:["This is similar to how programming languages have ",(0,l.jsx)(s.strong,{children:"Abstract Syntax Trees (AST)"})," that describe the syntax of the language which then goes through the ",(0,l.jsx)(s.strong,{children:"interpreter"})," to be executed.\nJust like ASTs, to get our code working, we need to write an interpreter to evaluate our data structure and produce effects."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," interpreter = eff => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(contents) => contents\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, getNext) =>\n    readFile(fileName)->getNext->interpreter\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(fileName, contents, getNext) => {\n    writeFile(fileName, contents);\n    ",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),"->getNext->interpreter;\n  }\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," result = interpreter(appendStringToFile(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"./file"'}),", ",(0,l.jsx)(s.span,{className:"hljs-string",children:'"hello world"'}),"));\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["The interpreter walks through the list-like structure and calls itself recursively on each of the nodes till it hits ",(0,l.jsx)(s.code,{children:"Return"}),"."]}),"\n",(0,l.jsx)(s.p,{children:'Kevin: "Why is this better than writing it imperatively?"'}),"\n",(0,l.jsx)(s.p,{children:"*takes a deep breath*\nKevin... STFU!"}),"\n",(0,l.jsxs)(s.p,{children:["This is better because it ",(0,l.jsx)(s.strong,{children:"decouples"})," your ",(0,l.jsx)(s.strong,{children:"business logic"})," from the ",(0,l.jsx)(s.strong,{children:"effects"}),"!\nThis is better because you can just create a ",(0,l.jsx)(s.strong,{children:"mock interpreter"})," and ",(0,l.jsx)(s.strong,{children:"write tests for your business logic"})," without actually generating effects!\nThis is better because you get ",(0,l.jsx)(s.strong,{children:"dependency injection"})," for free!"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Are we composable yet?"}),"\n",(0,l.jsxs)(s.p,{children:["Now we have a new problem though. It seems like ",(0,l.jsx)(s.code,{children:"Return"})," will have to be defined for every kind of effect we may have.\nThis will also make it difficult to ",(0,l.jsx)(s.strong,{children:"compose"})," it with other effects.\nSo let's abstract that out."]}),"\n",(0,l.jsx)(s.p,{children:"We can create a module function for creating effects and handling the recursion in the interpreter."}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"EFFECT"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MakeEffect"})," = (",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),": ",(0,l.jsx)(s.span,{className:"hljs-type",children:"EFFECT"}),") => {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),", ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'ret"}),"> = \n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'ret"}),")\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Operation"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),".t<t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),", ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'ret"}),">>)\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," interpreter = (eff, handler) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(x) => x\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Operation"}),"(m) => handler(m)->interpreter(handler)\n  }\n}\n"]})}),"\n",(0,l.jsx)(s.p,{children:"Then we can rewrite our file effect in peace."}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> =\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),")\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"unit"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),")\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"})," = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MakeEffect"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),")\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," appendStringToFile = (fileName, logLine) => {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"open"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),";\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"open"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),";\n\n  ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Operation"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, contents =>\n    ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Operation"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(fileName, contents",(0,l.jsx)(s.span,{className:"hljs-operator",children:" ++ "}),"logLine, _ =>\n      ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Operation"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, contents =>\n        ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(contents)\n      ))\n    ))\n  ))\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," handler = eff => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, resume) => readFile(fileName)->resume;\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(fileName, contents, resume) => {\n    writeFile(fileName, contents);\n    resume(",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),");\n  }\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," result = appendStringToFile->",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),".interpreter(handler)\n"]})}),"\n",(0,l.jsxs)(s.blockquote,{children:["\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.strong,{children:'"Effects as a data structure is cool and all but I don\'t want to write code that looks like a ladder"'})}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Former student who died under suspicious circumstances shortly after making this statement"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.p,{children:["I get it. It looks ugly. All new-born babies do. We just need some ",(0,l.jsx)(s.em,{children:"SYNTAX SUGAR"})," to make things better.\nDon't worry tho. I got you. But before we go there, we need to implement a ",(0,l.jsx)(s.code,{children:"flatMap"})," operation for our effect."]}),"\n",(0,l.jsxs)(s.p,{children:["You may know ",(0,l.jsx)(s.code,{children:"flatMap"})," from it's critically acclaimed role in ",(0,l.jsx)(s.code,{children:"Belt.Option"})," and ",(0,l.jsx)(s.code,{children:"Belt.Result"})," modules. Also, the horrible ",(0,l.jsx)(s.code,{children:"Js.Promise.then_"}),", is also a ",(0,l.jsx)(s.code,{children:"flatMap"})," on promises.\nIn general, ",(0,l.jsx)(s.code,{children:"flatMap: t<'a> => ('a => t<'b>) => t<'b> "})," allows us to chain ",(0,l.jsx)(s.code,{children:"t<'a>"})," to ",(0,l.jsx)(s.code,{children:"t<'b>"})," using the result of ",(0,l.jsx)(s.code,{children:"t<'a>"}),"."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-comment",children:"// This is a map operation over our file operation"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," fileOpsMap = (eff, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(f, next) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(f, e => e->next->fn)\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(f, c, next) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(f, c, e => e->next->fn)\n}\n\n",(0,l.jsx)(s.span,{className:"hljs-comment",children:"// This function allows us to chain our effects together"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," flatMap = (eff, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(a) => fn(a)\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(m) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(m->fileOpsMap(flatMap(_, fn)))\n}\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["While we're at it, we'll also need another function called ",(0,l.jsx)(s.code,{children:"liftEff"}),".\nThis function ",(0,l.jsx)(s.strong,{children:"lifts"})," any given operation into an ",(0,l.jsx)(s.code,{children:"Effect"})," and makes it terminate with its result.\n",(0,l.jsx)(s.code,{children:"x => next effect?"})," becomes ",(0,l.jsx)(s.code,{children:"Eff(x => Return(x))"})]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," liftEff = fa => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(fa->fileOpsMap(e => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(e)));\n"]})}),"\n",(0,l.jsx)(s.p,{children:"Now putting it all together, our effects helper and file effect will look something like this"}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"EFFECT"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">;\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," map : t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> => (",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'b"}),") => t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'b"}),">;\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MakeEffect"})," = (",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),": ",(0,l.jsx)(s.span,{className:"hljs-type",children:"EFFECT"}),") => {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> = \n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),")\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),".t<t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),">>);\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," liftEff = fa => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(fa->",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),".map(e => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(e)));\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," flatMap = (eff, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(a) => fn(a)\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(m) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(m->",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),".map(flatMap(_, fn)))\n  };\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," interpreter = (eff, handler) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Return"}),"(x) => x\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Eff"}),"(m) => handler(m)->interpreter(handler)\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> =\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),")\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"unit"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),");\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," map = (eff, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(f, next) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(f, e => e->next->fn)\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(f, c, next) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(f, c, e => e->next->fn)\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"})," = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MakeEffect"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),");\n\n",(0,l.jsx)(s.span,{className:"hljs-comment",children:"// Lifted helper functions"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," readFileOp = file =>\n  ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),".liftEff(",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(file, x => x));\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," writeFileOp = (file, contents) =>\n  ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),".liftEff(",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(file, contents, x => x));\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["Now for the ",(0,l.jsx)(s.em,{children:"SYNTAX SUGAR"})," I promised!"]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," appendStringToFile = (fileName, logLine) => {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"open"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),";\n\n  readFileOp(fileName)\n  ->flatMap(contents => writeFileOp(fileName, contents",(0,l.jsx)(s.span,{className:"hljs-operator",children:" ++ "}),"logLine))\n  ->flatMap(_ => readFileOp(fileName))\n};\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["We have turned our ",(0,l.jsx)(s.code,{children:"FileOperations"})," into a functor"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"No, not that functor, the other functor."}),"\n",(0,l.jsxs)(s.p,{children:["Functors in ocaml (",(0,l.jsx)(s.a,{href:"https://rescript-lang.org/docs/manual/latest/module#module-functions-functors",children:"module functions"}),") are very different from functors in category theory."]}),"\n",(0,l.jsxs)(s.p,{children:["What we have made here is a combination of both kinds of functors.\nThe ",(0,l.jsx)(s.code,{children:"FileOperations"})," ",(0,l.jsx)(s.strong,{children:"functor"})," (category theory) goes into the ",(0,l.jsx)(s.code,{children:"MakeEffect"})," ",(0,l.jsx)(s.strong,{children:"functor"})," (module function) and returns ",(0,l.jsx)(s.code,{children:"FileEffect"})," ",(0,l.jsx)(s.strong,{children:"monad"})," (category theory)."]}),"\n",(0,l.jsxs)(s.blockquote,{children:["\n",(0,l.jsx)(s.p,{children:"Fun fact: Functor comes from the contraction of, fun which is Russian for vodka, ca which of course is the sound a crow makes and tor which is a modern tin foil hat that actually works."}),"\n"]}),"\n",(0,l.jsxs)(s.blockquote,{children:["\n",(0,l.jsx)(s.p,{children:"Fun fact: Monad comes from the mind of a mathematician who forgot about the essay that was due, so at the last minute, started making up words to fill up the 800 words."}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Don't quote me on that but it's probably true. We'll never know."}),"\n",(0,l.jsx)(s.p,{children:"We don't have to get into the specifics of functors and monads to make sense of this class but it is worth the learning curve."}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Ugh.. Unit tests"}),"\n",(0,l.jsxs)(s.p,{children:["Writing tests for it is as simple as creating ",(0,l.jsx)(s.strong,{children:"a mock handler"}),"."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," mockFile = ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"ref"}),"(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"init:"'}),");\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," mockHandler = eff => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, resume) => resume(mockFile.contents);\n  | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(fileName, contents, resume) => {\n    mockFile.contents = contents;\n    resume(",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),");\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," result = appendStringToFile(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"./file"'}),", ",(0,l.jsx)(s.span,{className:"hljs-string",children:'"text to append"'}),")\n  ->",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),".interpreter(mockHandler);\n\nexpect.",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),"(result).toEqual(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"init:text to append"'}),");\nexpect.",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),"(mockFile.contents).toEqual(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"init:text to append"'}),");\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["And now for the best part... ",(0,l.jsx)(s.em,{children:"drum rolls"})]}),"\n",(0,l.jsx)(s.p,{children:(0,l.jsx)(s.strong,{children:"SNAPSHOT/GOLDEN TESTING"})}),"\n",(0,l.jsx)(s.p,{children:"Yes! As all our business logic is now just a data structure, you can create a snapshot of it to test against!"}),"\n",(0,l.jsxs)(s.p,{children:["You can perform snapshot testing of your effect by ",(0,l.jsx)(s.strong,{children:"accumulating the effects"})," called on your handler as an array."]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," nodes = ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"ref"}),"(",(0,l.jsx)(s.span,{className:"hljs-literal",children:"[]"}),"->",(0,l.jsx)(s.span,{className:"hljs-type",children:"Obj"}),".magic);\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," addNode = node => nodes.contents = nodes.contents->",(0,l.jsx)(s.span,{className:"hljs-type",children:"Belt"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"Array"}),".concat([node]);\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," mockHandler = eff => {\n  addNode(eff);\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(_f, resume) => resume(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"mock file contents"'}),")\n    | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(_f, _c, resume) => resume(",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),")\n  };\n};\n\nappendStringToFile(",(0,l.jsx)(s.span,{className:"hljs-string",children:'"./file"'}),", ",(0,l.jsx)(s.span,{className:"hljs-string",children:'"text to append"'}),")->",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileEffect"}),".interpreter(mockHandler)->ignore;\n\nexpect.value(nodes).toMatchSnapshot",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),";\n"]})}),"\n",(0,l.jsx)(s.p,{children:"And just like that, all of our business logic is now 100% safe against all kinds of refactor."}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"You change the order of effects?... Tests break!"}),"\n",(0,l.jsx)(s.li,{children:"You add another effect in between?... Tests break!"}),"\n",(0,l.jsx)(s.li,{children:"You accidentally delete everything?... Tests explodes!"}),"\n",(0,l.jsx)(s.li,{children:"You got scammed by a Nigerian prince?... This won't help with that!"}),"\n",(0,l.jsx)(s.li,{children:"You change something that doesn't impact your program?... Tests pass!"}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Effect composition"}),"\n",(0,l.jsxs)(s.p,{children:["File IO is great but your code will involve other effects too.\nMaybe you want to implement ",(0,l.jsx)(s.strong,{children:"logging"}),"? Or maybe some ",(0,l.jsx)(s.strong,{children:"caching"})," mechanism? Or maybe you just want to maintain a piece of ",(0,l.jsx)(s.strong,{children:"mutable state"})," in your code?\nJust having one effect called ",(0,l.jsx)(s.code,{children:"FileEffect"})," is not gonna cut it."]}),"\n",(0,l.jsxs)(s.p,{children:["To be able to compose multiple effects into one big effect, we can use the almighty ",(0,l.jsx)(s.a,{href:"https://rescript-lang.org/docs/manual/latest/polymorphic-variant",children:"STRUCTURAL/POLYMORPHIC VARIANTS"}),"!"]}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-comment",children:"// File IO effect"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> = [ #",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),") | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"unit"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),") ];\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," map = (eff, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(f, next) => #",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(f, e => e->next->fn)\n    | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(f, c, next) => #",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(f, c, e => e->next->fn)\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-comment",children:"// Logger effect"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"LoggerOperations"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> = [ #",(0,l.jsx)(s.span,{className:"hljs-type",children:"LogMessage"}),"(",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"}),", ",(0,l.jsx)(s.span,{className:"hljs-built_in",children:"string"})," => ",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),") ];\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," map = (eff, fn) => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"LogMessage"}),"(m, d, next) => #",(0,l.jsx)(s.span,{className:"hljs-type",children:"LogMessage"}),"(m, d, e => e->next->fn)\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-comment",children:"// Composition of FileOperations and LoggerOperations"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomOperations"})," = {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"type"})," ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"rec"})," t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> = [ ",(0,l.jsx)(s.span,{className:"hljs-type",children:"LoggerOperations"}),".t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> | ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".t<",(0,l.jsx)(s.span,{className:"hljs-symbol",children:"'a"}),"> ];\n\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," map = eff => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n    | #...",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".t ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"as"})," e => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"FileOperations"}),".map(e)\n    | #...",(0,l.jsx)(s.span,{className:"hljs-type",children:"LoggerOperations"}),".t ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"as"})," e => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"LoggerOperations"}),".map(e)\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"module"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomEff"})," = ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MakeEffect"}),"(",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomOperations"}),");\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," logMessageOp = (message, data) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomEff"}),".liftEff(#",(0,l.jsx)(s.span,{className:"hljs-type",children:"LogMessage"}),"(message, data, x => x));\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," readFileOp = file => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomEff"}),".liftEff(#",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(file, x => x));\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," writeFileOp = (file, contents) => ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomEff"}),".liftEff(#",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(file, contents, x => x));\n\n",(0,l.jsx)(s.span,{className:"hljs-comment",children:"// Our program"}),"\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," appendStringToFile = (fileName, logLine) => {\n  ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"open"})," ",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomEff"}),";\n\n  readFileOp(fileName)\n  ->flatMap(logMessageOp(",(0,l.jsx)(s.span,{className:"hljs-string",children:'":: Logging file contents before update -"'}),"))\n  ->flatMap(contents => writeFileOp(fileName, contents",(0,l.jsx)(s.span,{className:"hljs-operator",children:" ++ "}),"logLine))\n  ->flatMap(_ => readFileOp(fileName))\n  ->flatMap(logMessageOp(",(0,l.jsx)(s.span,{className:"hljs-string",children:'":: Logging file contents after update -"'}),"))\n};\n"]})}),"\n",(0,l.jsxs)(s.p,{children:["You can ",(0,l.jsx)(s.strong,{children:"compose any number of effects"})," together into one for your programs!"]}),"\n",(0,l.jsx)(s.p,{children:"And of course, nothing would work without the handler so..."}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsxs)(s.code,{className:"hljs language-reasonml",children:[(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," handler = eff => ",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"switch"})," eff {\n  | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"LogMessage"}),"(message, data, resume) => {\n    ",(0,l.jsx)(s.span,{className:"hljs-type",children:"Js"}),".log2(message, data);\n    resume(data);\n  }\n  | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"ReadFile"}),"(fileName, resume) => readFile(fileName)->resume;\n  | #",(0,l.jsx)(s.span,{className:"hljs-type",children:"WriteFile"}),"(fileName, contents, resume) => {\n    writeFile(fileName, contents);\n    resume(",(0,l.jsx)(s.span,{className:"hljs-literal",children:"()"}),");\n  };\n};\n\n",(0,l.jsx)(s.span,{className:"hljs-keyword",children:"let"})," result = appendStringToFile->",(0,l.jsx)(s.span,{className:"hljs-type",children:"MyCustomEff"}),".interpreter(handler);\n"]})}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Does all of this have a name?"}),"\n",(0,l.jsxs)(s.p,{children:["What we just learned is a construct in functional programming called ",(0,l.jsx)(s.a,{href:"https://wiki.haskell.org/Free_structure",children:"free algebraic structures"}),". More specifically, ",(0,l.jsx)(s.code,{children:"FileEffect"})," and ",(0,l.jsx)(s.code,{children:"MyCustomEff"})," are Free Monads."]}),"\n",(0,l.jsxs)(s.p,{children:["In general, a free monad on a Functor ",(0,l.jsx)(s.code,{children:"f"})," is a structure where each node represents ",(0,l.jsx)(s.code,{children:"f"}),". If you understood what I just said, please explain it to me after class so I don't look like an idiot in front of my other students."]}),"\n",(0,l.jsxs)(s.p,{children:["In this class, we used it to ",(0,l.jsx)(s.strong,{children:"fold"})," (interpret) a data structure to generate effects.\nIt allowed us to decouple the composition of our effects with the effect's behavior by creating a pure representation of our computations."]}),"\n",(0,l.jsxs)(s.p,{children:["Free monad implementation for dealing with effects in such a way is also referred to as ",(0,l.jsx)(s.a,{href:"https://overreacted.io/algebraic-effects-for-the-rest-of-us/",children:"algebraic effects"}),"."]}),"\n",(0,l.jsx)(s.p,{children:"To learn more about this, you could walk through the following links -"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.a,{href:"https://rescript-lang.org/docs/manual/latest/module#module-functions-functors",children:"What the fuck are module functions/functors?"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.a,{href:"https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6",children:"What the fuck is a Functor in category theory?"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.a,{href:"https://wiki.haskell.org/All_About_Monads",children:"What the fuck is a Monad?"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.a,{href:"https://wiki.haskell.org/Free_structure",children:"What the fuck are Free Algebraic Structures?"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.a,{href:"https://overreacted.io/algebraic-effects-for-the-rest-of-us/",children:"What the fuck are algebraic effects?"})}),"\n"]}),"\n",(0,l.jsx)(s.hr,{}),"\n",(0,l.jsx)(s.h2,{children:"Report card"}),"\n",(0,l.jsxs)(s.p,{children:["Our jobs as programmers is to create as many ",(0,l.jsx)(s.strong,{children:"guarantees"})," in our code as possible.\nTo achieve this, we should always try to design things in a way that pushes everything we can't guarantee to the edges."]}),"\n",(0,l.jsxs)(s.p,{children:["This not only reduces the ",(0,l.jsx)(s.strong,{children:"surface area for bugs"}),", but also reduces the ",(0,l.jsx)(s.strong,{children:"mental overhead"})," to the person reading the code."]}),"\n",(0,l.jsx)(s.p,{children:"This is why we should always try to minimize the surface area of impurity in our code."}),"\n",(0,l.jsx)(s.p,{children:"With free monads, we create a guarantee that our business logic is sound and we push the effects to the edge in the form of our interpreter since we may not be able to guarantee the correctness of effectful behavior."}),"\n",(0,l.jsx)(s.p,{children:'Anyways, impure programs get a C for "Can do better". Almost-pure programs with Free monads, get an A for "Aahaaa, functional programming wins again".'}),"\n",(0,l.jsx)(s.p,{children:"Alright kids, get a signature on the report card from your parents. No fake signatures, John. Those squiggly lines aren't fooling anyone."})]})}s.default=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,a.ah)(),e.components);return s?(0,l.jsx)(s,Object.assign({},e,{children:(0,l.jsx)(i,e)})):i(e)}}}]);