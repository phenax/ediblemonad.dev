<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="icon" href="/favicon.ico" type="image/x-icon"/><title>Designing effects as data structures<!-- --> - Blog - Akshay Nair</title><meta name="description" content="Dipping our feet into the world of effect handlers to design composition of our effects as a data-structure with free monads"/><meta name="next-head-count" content="6"/><link rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/103f6172f9496d3d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/103f6172f9496d3d.css" data-n-g=""/><link rel="preload" href="/_next/static/css/64930e3055f5cdfd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/64930e3055f5cdfd.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8344679a38250489.js" defer=""></script><script src="/_next/static/chunks/framework-6564377a49303cf2.js" defer=""></script><script src="/_next/static/chunks/main-09d1f590d0066570.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8af340429d7c0297.js" defer=""></script><script src="/_next/static/chunks/660-39c229660589c9c2.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-748333d840764e96.js" defer=""></script><script src="/_next/static/OS3xMTDMcxtkWoRrNFNqv/_buildManifest.js" defer=""></script><script src="/_next/static/OS3xMTDMcxtkWoRrNFNqv/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="__className_ad7b13"><header class="layout_header__H1FPN !pt-4 !pb-8"><span class="layout_bubble__VpDJP"></span><div class=" relative text-right flex px-6 justify-around gap-3 text-base align-top inline-block text-sm max-w-[800px] m-auto" style="margin-top:0.8rem"><div class="pt-1"><a class="layout_navLink__eokNB " href="/">Projects</a></div><div class="pt-1"><a class="layout_navLink__eokNB " href="/about">About</a></div><div class="pt-1"><a class="layout_navLink__eokNB " href="/blog">Blog</a><span class="absolute text-slate-600 ml-1 mt-0.5 w-full text-left max-md:hidden">/<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="circle-dot" class="svg-inline--fa fa-circle-dot fa-xs ml-1" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M464 256A208 208 0 1 0 48 256a208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zm256-96a96 96 0 1 1 0 192 96 96 0 1 1 0-192z"></path></svg></span></div><div class="pt-1"><a class="layout_navLink__eokNB " href="https://desmos.ediblemonad.dev">Desmos</a></div><div class="pt-1"><a class="layout_navLink__eokNB " href="/contact">Links</a></div></div></header><main class="page_main__LgpvM"><article class="prose prose-invert max-w-full"><h1 class="text-accent-1">Designing effects as data structures</h1><!--$?--><template id="B:0"></template><!--/$--><hr/></article><div class="[&amp;&gt;.utterances]:max-w-none py-6 px-3"></div></main></div></div><div hidden id="S:0"><p>You gotta teach your effects some manners.</p>
<p>We work with effects everyday, but those rascals have a habit of running around loose in our programs.
I&#x27;m not saying it&#x27;s just bad parenting but we have to draw the line at some point.</p>
<p>Look at pure functions, they are so disciplined and obedient. They never get into any trouble.
You ask them a question, they give you an answer. That&#x27;s what you expect from good code.
If you find out that your function, while giving you the answer, also went ahead and made 5 api calls, thats a good sign that your code needs some disciplining.</p>
<hr/>
<h2>Let&#x27;s implement a linked list</h2>
<p>I swear this is relevant and not a plot to make you learn DSA again.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> myList&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-type">Nil</span> | <span class="hljs-type">Cons</span>(<span class="hljs-symbol">&#x27;a</span>, myList&lt;<span class="hljs-symbol">&#x27;a</span>&gt;)

<span class="hljs-keyword">let</span> ls = <span class="hljs-type">Cons</span>(<span class="hljs-number">5</span>, <span class="hljs-type">Cons</span>(<span class="hljs-number">20</span>, <span class="hljs-type">Cons</span>(-<span class="hljs-number">28</span>, <span class="hljs-type">Nil</span>)))
</code></pre>
<p>That is a simple <strong>linked list</strong> implemented in <a href="https://rescript-lang.org/">rescript</a>.
<code>Nil</code> marks the end of the list and every element before it contains an item of that list and the rest of the list.
They know how to stand in a straight line like good students.</p>
<p>But, this is an <strong>eager list</strong> since all items of the list already exist on the time of its creation. For what we&#x27;re working on today, eager lists won&#x27;t be enough. We need our list to be <em>lazy</em>.
We can turn that into a <strong>lazy linked list</strong> by replacing the rest of the list with a function returning the rest of the list like so -</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> lazyList&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-type">Nil</span> | <span class="hljs-type">Cons</span>(<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-built_in">unit</span> =&gt; lazyList&lt;<span class="hljs-symbol">&#x27;a</span>&gt;)

<span class="hljs-keyword">let</span> ls = <span class="hljs-type">Cons</span>(<span class="hljs-number">5</span>, <span class="hljs-literal">()</span> =&gt;
  <span class="hljs-type">Cons</span>(<span class="hljs-number">20</span>, <span class="hljs-literal">()</span> =&gt;
    <span class="hljs-type">Cons</span>(<span class="hljs-number">512</span>, <span class="hljs-literal">()</span> =&gt;
      <span class="hljs-type">Nil</span>)))
</code></pre>
<p>This makes it so the rest of the linked list doesn&#x27;t exist till the function is called.
This is helpful if you wanted to create an <strong>infinite list</strong>.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> fibonacci = (a, b) =&gt; <span class="hljs-type">Cons</span>(b, <span class="hljs-literal">()</span> =&gt; fibonacci(b, a<span class="hljs-operator"> + </span>b))

<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> take = (ls, n) =&gt; <span class="hljs-keyword">switch</span> (n, ls) {
  | (_, <span class="hljs-type">Nil</span>) | (<span class="hljs-number">0</span>, _) =&gt; <span class="hljs-type">Nil</span>
  | (n, <span class="hljs-type">Cons</span>(value, next)) =&gt; <span class="hljs-type">Cons</span>(value, <span class="hljs-literal">()</span> =&gt; next<span class="hljs-literal">()</span>-&gt;take(n - <span class="hljs-number">1</span>))
}

<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> forEach = (ls, fn) =&gt; <span class="hljs-keyword">switch</span> ls {
  | <span class="hljs-type">Nil</span> =&gt; <span class="hljs-literal">()</span>
  | <span class="hljs-type">Cons</span>(value, next) =&gt; {
    fn(value)
    next<span class="hljs-literal">()</span>-&gt;forEach(fn)
  }
}

fibonacci(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)-&gt;take(<span class="hljs-number">20</span>)-&gt;forEach(<span class="hljs-type">Js</span>.log)
</code></pre>
<p><code>fibonacci</code> returns a lazy list of all the numbers in Fibonacci series starting with <code>a</code> and <code>b</code>. We then use the <code>take</code> function to ignore the list after the first <code>20</code> items. <code>forEach</code>, then goes through the new list till the 20 items and logs each one out.</p>
<p>This is very helpful for <strong>modeling continuous sequences</strong> of data without consuming all the space it may need.</p>
<p>Everything we&#x27;ve played with so far has been <em>simple</em> and <em>pure</em>. Unlike those disobedient effects passing notes to each other, non-deterministically. Oh I hate them so much.</p>
<hr/>
<h2>Can effects be more like that?</h2>
<p>Close your eyes. No, seriously, close them. This is important.
Now, imagine a world where all your effectful code could just be designed as <em>data structures</em>!
Are your eyes still closed? Good.
Something as simple as a linked list that describes all the effectful logic in your code.
Writing tests will become fun!
Everything would be so much simpler. All of our life&#x27;s problems would just disappear.</p>
<p>Well, today&#x27;s yo... Oh you can open your eyes now. Sorry.
Well, today&#x27;s your lucky day!</p>
<p>We will turn your ill-mannered effects into well behaved pure data structures.</p>
<hr/>
<h2>Impure effect? More like code neglect, amirite? Please clap</h2>
<p>Kids, please turn in your assignment from last week. I hope you all implemented <code>appendStringToFile: string =&gt; string =&gt; string</code> that appends a string to a file and returns the new contents, given the imaginary synchronous functions <code>readFile: string =&gt; string</code> and <code>writeFile: string =&gt; string =&gt; ()</code> for doing file IO.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> appendStringToFile = (fileName, logLine) =&gt; {
  <span class="hljs-keyword">let</span> contents = readFile(fileName)
  writeFile(contents<span class="hljs-operator"> ++ </span>logLine)
  readFile(fileName)
}

<span class="hljs-keyword">let</span> newLogContents = appendStringToFile(fileName, <span class="hljs-string">&quot;\nSome text&quot;</span>)
</code></pre>
<p>Oh my god, Timmy! Is that imperative and impure function calls in your notebook? That&#x27;s it. To the principals office! Now!</p>
<p>Now let&#x27;s try to think of a way to do this that&#x27;s not an absolute nightmare to test.
What if we just made a data structure out of it?</p>
<p>Let&#x27;s try turning each of those statements into variants that can be linked together lazily.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> fileEff&lt;<span class="hljs-symbol">&#x27;a</span>&gt; =
  | <span class="hljs-type">ReadFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> =&gt; fileEff&lt;<span class="hljs-symbol">&#x27;a</span>&gt;)
  | <span class="hljs-type">WriteFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">unit</span> =&gt; fileEff&lt;<span class="hljs-symbol">&#x27;a</span>&gt;)
  | <span class="hljs-type">Return</span>(<span class="hljs-built_in">string</span>)

<span class="hljs-keyword">let</span> appendStringToFile = (fileName, logLine) =&gt;
  <span class="hljs-type">ReadFile</span>(fileName, contents =&gt;
    <span class="hljs-type">WriteFile</span>(fileName, contents<span class="hljs-operator"> ++ </span>logLine, _ =&gt;
      <span class="hljs-type">ReadFile</span>(fileName, newContents =&gt;
        <span class="hljs-type">Return</span>(newContents))))
</code></pre>
<p>You can read <code>Something(a, b, c =&gt; fileEff&lt;&#x27;a&gt;)</code> as an operation <code>Something</code> that takes <code>a</code> and <code>b</code> and returns a <code>c</code>.</p>
<p>If you squint hard enough, you&#x27;ll find that this is very similar to the <strong>lazy list</strong> data structure we implemented earlier.
You have the last item <code>Return</code>, and each item before it is a description of an effect.</p>
<p>This is similar to how programming languages have <strong>Abstract Syntax Trees (AST)</strong> that describe the syntax of the language which then goes through the <strong>interpreter</strong> to be executed.
Just like ASTs, to get our code working, we need to write an interpreter to evaluate our data structure and produce effects.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> interpreter = eff =&gt; <span class="hljs-keyword">switch</span> eff {
  | <span class="hljs-type">Return</span>(contents) =&gt; contents
  | <span class="hljs-type">ReadFile</span>(fileName, getNext) =&gt;
    readFile(fileName)-&gt;getNext-&gt;interpreter
  | <span class="hljs-type">WriteFile</span>(fileName, contents, getNext) =&gt; {
    writeFile(fileName, contents);
    <span class="hljs-literal">()</span>-&gt;getNext-&gt;interpreter;
  }
}

<span class="hljs-keyword">let</span> result = interpreter(appendStringToFile(<span class="hljs-string">&quot;./file&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>));
</code></pre>
<p>The interpreter walks through the list-like structure and calls itself recursively on each of the nodes till it hits <code>Return</code>.</p>
<p>Kevin: &quot;Why is this better than writing it imperatively?&quot;</p>
<p>*takes a deep breath*
Kevin... STFU!</p>
<p>This is better because it <strong>decouples</strong> your <strong>business logic</strong> from the <strong>effects</strong>!
This is better because you can just create a <strong>mock interpreter</strong> and <strong>write tests for your business logic</strong> without actually generating effects!
This is better because you get <strong>dependency injection</strong> for free!</p>
<hr/>
<h2>Are we composable yet?</h2>
<p>Now we have a new problem though. It seems like <code>Return</code> will have to be defined for every kind of effect we may have.
This will also make it difficult to <strong>compose</strong> it with other effects.
So let&#x27;s abstract that out.</p>
<p>We can create a module function for creating effects and handling the recursion in the interpreter.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">EFFECT</span> = {
  <span class="hljs-keyword">type</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt;
}

<span class="hljs-keyword">module</span> <span class="hljs-type">MakeEffect</span> = (<span class="hljs-type">Eff</span>: <span class="hljs-type">EFFECT</span>) =&gt; {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;ret</span>&gt; = 
    | <span class="hljs-type">Return</span>(<span class="hljs-symbol">&#x27;ret</span>)
    | <span class="hljs-type">Operation</span>(<span class="hljs-type">Eff</span>.t&lt;t&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;ret</span>&gt;&gt;)

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> interpreter = (eff, handler) =&gt; <span class="hljs-keyword">switch</span> eff {
    | <span class="hljs-type">Return</span>(x) =&gt; x
    | <span class="hljs-type">Operation</span>(m) =&gt; handler(m)-&gt;interpreter(handler)
  }
}
</code></pre>
<p>Then we can rewrite our file effect in peace.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">module</span> <span class="hljs-type">FileOperations</span> = {
  <span class="hljs-keyword">type</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; =
    | <span class="hljs-type">ReadFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> =&gt; <span class="hljs-symbol">&#x27;a</span>)
    | <span class="hljs-type">WriteFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-symbol">&#x27;a</span>)
}

<span class="hljs-keyword">module</span> <span class="hljs-type">FileEffect</span> = <span class="hljs-type">MakeEffect</span>(<span class="hljs-type">FileOperations</span>)

<span class="hljs-keyword">let</span> appendStringToFile = (fileName, logLine) =&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-type">FileOperations</span>;
  <span class="hljs-keyword">open</span> <span class="hljs-type">FileEffect</span>;

  <span class="hljs-type">Operation</span>(<span class="hljs-type">ReadFile</span>(fileName, contents =&gt;
    <span class="hljs-type">Operation</span>(<span class="hljs-type">WriteFile</span>(fileName, contents<span class="hljs-operator"> ++ </span>logLine, _ =&gt;
      <span class="hljs-type">Operation</span>(<span class="hljs-type">ReadFile</span>(fileName, contents =&gt;
        <span class="hljs-type">Return</span>(contents)
      ))
    ))
  ))
}

<span class="hljs-keyword">let</span> handler = eff =&gt; <span class="hljs-keyword">switch</span> eff {
  | <span class="hljs-type">ReadFile</span>(fileName, resume) =&gt; readFile(fileName)-&gt;resume;
  | <span class="hljs-type">WriteFile</span>(fileName, contents, resume) =&gt; {
    writeFile(fileName, contents);
    resume(<span class="hljs-literal">()</span>);
  }
}

<span class="hljs-keyword">let</span> result = appendStringToFile-&gt;<span class="hljs-type">FileEffect</span>.interpreter(handler)
</code></pre>
<blockquote>
<p><strong>&quot;Effects as a data structure is cool and all but I don&#x27;t want to write code that looks like a ladder&quot;</strong></p>
<ul>
<li>Former student who died under suspicious circumstances shortly after making this statement</li>
</ul>
</blockquote>
<p>I get it. It looks ugly. All new-born babies do. We just need some <em>SYNTAX SUGAR</em> to make things better.
Don&#x27;t worry tho. I got you. But before we go there, we need to implement a <code>flatMap</code> operation for our effect.</p>
<p>You may know <code>flatMap</code> from it&#x27;s critically acclaimed role in <code>Belt.Option</code> and <code>Belt.Result</code> modules. Also, the horrible <code>Js.Promise.then_</code>, is also a <code>flatMap</code> on promises.
In general, <code>flatMap: t&lt;&#x27;a&gt; =&gt; (&#x27;a =&gt; t&lt;&#x27;b&gt;) =&gt; t&lt;&#x27;b&gt; </code> allows us to chain <code>t&lt;&#x27;a&gt;</code> to <code>t&lt;&#x27;b&gt;</code> using the result of <code>t&lt;&#x27;a&gt;</code>.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-comment">// This is a map operation over our file operation</span>
<span class="hljs-keyword">let</span> fileOpsMap = (eff, fn) =&gt; <span class="hljs-keyword">switch</span> eff {
  | <span class="hljs-type">ReadFile</span>(f, next) =&gt; <span class="hljs-type">ReadFile</span>(f, e =&gt; e-&gt;next-&gt;fn)
  | <span class="hljs-type">WriteFile</span>(f, c, next) =&gt; <span class="hljs-type">WriteFile</span>(f, c, e =&gt; e-&gt;next-&gt;fn)
}

<span class="hljs-comment">// This function allows us to chain our effects together</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> flatMap = (eff, fn) =&gt; <span class="hljs-keyword">switch</span> eff {
  | <span class="hljs-type">Return</span>(a) =&gt; fn(a)
  | <span class="hljs-type">Eff</span>(m) =&gt; <span class="hljs-type">Eff</span>(m-&gt;fileOpsMap(flatMap(_, fn)))
}
</code></pre>
<p>While we&#x27;re at it, we&#x27;ll also need another function called <code>liftEff</code>.
This function <strong>lifts</strong> any given operation into an <code>Effect</code> and makes it terminate with its result.
<code>x =&gt; next effect?</code> becomes <code>Eff(x =&gt; Return(x))</code></p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> liftEff = fa =&gt; <span class="hljs-type">Eff</span>(fa-&gt;fileOpsMap(e =&gt; <span class="hljs-type">Return</span>(e)));
</code></pre>
<p>Now putting it all together, our effects helper and file effect will look something like this</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">EFFECT</span> = {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt;;
  <span class="hljs-keyword">let</span> map : t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; =&gt; (<span class="hljs-symbol">&#x27;a</span> =&gt; <span class="hljs-symbol">&#x27;b</span>) =&gt; t&lt;<span class="hljs-symbol">&#x27;b</span>&gt;;
};

<span class="hljs-keyword">module</span> <span class="hljs-type">MakeEffect</span> = (<span class="hljs-type">Eff</span>: <span class="hljs-type">EFFECT</span>) =&gt; {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = 
    | <span class="hljs-type">Return</span>(<span class="hljs-symbol">&#x27;a</span>)
    | <span class="hljs-type">Eff</span>(<span class="hljs-type">Eff</span>.t&lt;t&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&gt;);

  <span class="hljs-keyword">let</span> liftEff = fa =&gt; <span class="hljs-type">Eff</span>(fa-&gt;<span class="hljs-type">Eff</span>.map(e =&gt; <span class="hljs-type">Return</span>(e)));

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> flatMap = (eff, fn) =&gt; <span class="hljs-keyword">switch</span> eff {
    | <span class="hljs-type">Return</span>(a) =&gt; fn(a)
    | <span class="hljs-type">Eff</span>(m) =&gt; <span class="hljs-type">Eff</span>(m-&gt;<span class="hljs-type">Eff</span>.map(flatMap(_, fn)))
  };

  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> interpreter = (eff, handler) =&gt; <span class="hljs-keyword">switch</span> eff {
    | <span class="hljs-type">Return</span>(x) =&gt; x
    | <span class="hljs-type">Eff</span>(m) =&gt; handler(m)-&gt;interpreter(handler)
  };
};

<span class="hljs-keyword">module</span> <span class="hljs-type">FileOperations</span> = {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; =
    | <span class="hljs-type">ReadFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> =&gt; <span class="hljs-symbol">&#x27;a</span>)
    | <span class="hljs-type">WriteFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-symbol">&#x27;a</span>);

  <span class="hljs-keyword">let</span> map = (eff, fn) =&gt; <span class="hljs-keyword">switch</span> eff {
    | <span class="hljs-type">ReadFile</span>(f, next) =&gt; <span class="hljs-type">ReadFile</span>(f, e =&gt; e-&gt;next-&gt;fn)
    | <span class="hljs-type">WriteFile</span>(f, c, next) =&gt; <span class="hljs-type">WriteFile</span>(f, c, e =&gt; e-&gt;next-&gt;fn)
  };
};

<span class="hljs-keyword">module</span> <span class="hljs-type">FileEffect</span> = <span class="hljs-type">MakeEffect</span>(<span class="hljs-type">FileOperations</span>);

<span class="hljs-comment">// Lifted helper functions</span>
<span class="hljs-keyword">let</span> readFileOp = file =&gt;
  <span class="hljs-type">FileEffect</span>.liftEff(<span class="hljs-type">FileOperations</span>.<span class="hljs-type">ReadFile</span>(file, x =&gt; x));

<span class="hljs-keyword">let</span> writeFileOp = (file, contents) =&gt;
  <span class="hljs-type">FileEffect</span>.liftEff(<span class="hljs-type">FileOperations</span>.<span class="hljs-type">WriteFile</span>(file, contents, x =&gt; x));
</code></pre>
<p>Now for the <em>SYNTAX SUGAR</em> I promised!</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> appendStringToFile = (fileName, logLine) =&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-type">FileEffect</span>;

  readFileOp(fileName)
  -&gt;flatMap(contents =&gt; writeFileOp(fileName, contents<span class="hljs-operator"> ++ </span>logLine))
  -&gt;flatMap(_ =&gt; readFileOp(fileName))
};
</code></pre>
<p>We have turned our <code>FileOperations</code> into a functor</p>
<hr/>
<h2>No, not that functor, the other functor.</h2>
<p>Functors in ocaml (<a href="https://rescript-lang.org/docs/manual/latest/module#module-functions-functors">module functions</a>) are very different from functors in category theory.</p>
<p>What we have made here is a combination of both kinds of functors.
The <code>FileOperations</code> <strong>functor</strong> (category theory) goes into the <code>MakeEffect</code> <strong>functor</strong> (module function) and returns <code>FileEffect</code> <strong>monad</strong> (category theory).</p>
<blockquote>
<p>Fun fact: Functor comes from the contraction of, fun which is Russian for vodka, ca which of course is the sound a crow makes and tor which is a modern tin foil hat that actually works.</p>
</blockquote>
<blockquote>
<p>Fun fact: Monad comes from the mind of a mathematician who forgot about the essay that was due, so at the last minute, started making up words to fill up the 800 words.</p>
</blockquote>
<p>Don&#x27;t quote me on that but it&#x27;s probably true. We&#x27;ll never know.</p>
<p>We don&#x27;t have to get into the specifics of functors and monads to make sense of this class but it is worth the learning curve.</p>
<hr/>
<h2>Ugh.. Unit tests</h2>
<p>Writing tests for it is as simple as creating <strong>a mock handler</strong>.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> mockFile = <span class="hljs-built_in">ref</span>(<span class="hljs-string">&quot;init:&quot;</span>);
<span class="hljs-keyword">let</span> mockHandler = eff =&gt; <span class="hljs-keyword">switch</span> eff {
  | <span class="hljs-type">FileOperations</span>.<span class="hljs-type">ReadFile</span>(fileName, resume) =&gt; resume(mockFile.contents);
  | <span class="hljs-type">FileOperations</span>.<span class="hljs-type">WriteFile</span>(fileName, contents, resume) =&gt; {
    mockFile.contents = contents;
    resume(<span class="hljs-literal">()</span>);
  };
};

<span class="hljs-keyword">let</span> result = appendStringToFile(<span class="hljs-string">&quot;./file&quot;</span>, <span class="hljs-string">&quot;text to append&quot;</span>)
  -&gt;<span class="hljs-type">FileEffect</span>.interpreter(mockHandler);

expect.<span class="hljs-built_in">string</span>(result).toEqual(<span class="hljs-string">&quot;init:text to append&quot;</span>);
expect.<span class="hljs-built_in">string</span>(mockFile.contents).toEqual(<span class="hljs-string">&quot;init:text to append&quot;</span>);
</code></pre>
<p>And now for the best part... <em>drum rolls</em></p>
<p><strong>SNAPSHOT/GOLDEN TESTING</strong></p>
<p>Yes! As all our business logic is now just a data structure, you can create a snapshot of it to test against!</p>
<p>You can perform snapshot testing of your effect by <strong>accumulating the effects</strong> called on your handler as an array.</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> nodes = <span class="hljs-built_in">ref</span>(<span class="hljs-literal">[]</span>-&gt;<span class="hljs-type">Obj</span>.magic);
<span class="hljs-keyword">let</span> addNode = node =&gt; nodes.contents = nodes.contents-&gt;<span class="hljs-type">Belt</span>.<span class="hljs-type">Array</span>.concat([node]);

<span class="hljs-keyword">let</span> mockHandler = eff =&gt; {
  addNode(eff);
  <span class="hljs-keyword">switch</span> eff {
    | <span class="hljs-type">FileOperations</span>.<span class="hljs-type">ReadFile</span>(_f, resume) =&gt; resume(<span class="hljs-string">&quot;mock file contents&quot;</span>)
    | <span class="hljs-type">FileOperations</span>.<span class="hljs-type">WriteFile</span>(_f, _c, resume) =&gt; resume(<span class="hljs-literal">()</span>)
  };
};

appendStringToFile(<span class="hljs-string">&quot;./file&quot;</span>, <span class="hljs-string">&quot;text to append&quot;</span>)-&gt;<span class="hljs-type">FileEffect</span>.interpreter(mockHandler)-&gt;ignore;

expect.value(nodes).toMatchSnapshot<span class="hljs-literal">()</span>;
</code></pre>
<p>And just like that, all of our business logic is now 100% safe against all kinds of refactor.</p>
<ul>
<li>You change the order of effects?... Tests break!</li>
<li>You add another effect in between?... Tests break!</li>
<li>You accidentally delete everything?... Tests explodes!</li>
<li>You got scammed by a Nigerian prince?... This won&#x27;t help with that!</li>
<li>You change something that doesn&#x27;t impact your program?... Tests pass!</li>
</ul>
<hr/>
<h2>Effect composition</h2>
<p>File IO is great but your code will involve other effects too.
Maybe you want to implement <strong>logging</strong>? Or maybe some <strong>caching</strong> mechanism? Or maybe you just want to maintain a piece of <strong>mutable state</strong> in your code?
Just having one effect called <code>FileEffect</code> is not gonna cut it.</p>
<p>To be able to compose multiple effects into one big effect, we can use the almighty <a href="https://rescript-lang.org/docs/manual/latest/polymorphic-variant">STRUCTURAL/POLYMORPHIC VARIANTS</a>!</p>
<pre><code class="hljs language-reasonml"><span class="hljs-comment">// File IO effect</span>
<span class="hljs-keyword">module</span> <span class="hljs-type">FileOperations</span> = {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = [ #<span class="hljs-type">ReadFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> =&gt; <span class="hljs-symbol">&#x27;a</span>) | #<span class="hljs-type">WriteFile</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-symbol">&#x27;a</span>) ];

  <span class="hljs-keyword">let</span> map = (eff, fn) =&gt; <span class="hljs-keyword">switch</span> eff {
    | #<span class="hljs-type">ReadFile</span>(f, next) =&gt; #<span class="hljs-type">ReadFile</span>(f, e =&gt; e-&gt;next-&gt;fn)
    | #<span class="hljs-type">WriteFile</span>(f, c, next) =&gt; #<span class="hljs-type">WriteFile</span>(f, c, e =&gt; e-&gt;next-&gt;fn)
  };
};

<span class="hljs-comment">// Logger effect</span>
<span class="hljs-keyword">module</span> <span class="hljs-type">LoggerOperations</span> = {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = [ #<span class="hljs-type">LogMessage</span>(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span> =&gt; <span class="hljs-symbol">&#x27;a</span>) ];

  <span class="hljs-keyword">let</span> map = (eff, fn) =&gt; <span class="hljs-keyword">switch</span> eff {
    | #<span class="hljs-type">LogMessage</span>(m, d, next) =&gt; #<span class="hljs-type">LogMessage</span>(m, d, e =&gt; e-&gt;next-&gt;fn)
  };
};

<span class="hljs-comment">// Composition of FileOperations and LoggerOperations</span>
<span class="hljs-keyword">module</span> <span class="hljs-type">MyCustomOperations</span> = {
  <span class="hljs-keyword">type</span> <span class="hljs-keyword">rec</span> t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = [ <span class="hljs-type">LoggerOperations</span>.t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; | <span class="hljs-type">FileOperations</span>.t&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ];

  <span class="hljs-keyword">let</span> map = eff =&gt; <span class="hljs-keyword">switch</span> eff {
    | #...<span class="hljs-type">FileOperations</span>.t <span class="hljs-keyword">as</span> e =&gt; <span class="hljs-type">FileOperations</span>.map(e)
    | #...<span class="hljs-type">LoggerOperations</span>.t <span class="hljs-keyword">as</span> e =&gt; <span class="hljs-type">LoggerOperations</span>.map(e)
  };
};

<span class="hljs-keyword">module</span> <span class="hljs-type">MyCustomEff</span> = <span class="hljs-type">MakeEffect</span>(<span class="hljs-type">MyCustomOperations</span>);

<span class="hljs-keyword">let</span> logMessageOp = (message, data) =&gt; <span class="hljs-type">MyCustomEff</span>.liftEff(#<span class="hljs-type">LogMessage</span>(message, data, x =&gt; x));
<span class="hljs-keyword">let</span> readFileOp = file =&gt; <span class="hljs-type">MyCustomEff</span>.liftEff(#<span class="hljs-type">ReadFile</span>(file, x =&gt; x));
<span class="hljs-keyword">let</span> writeFileOp = (file, contents) =&gt; <span class="hljs-type">MyCustomEff</span>.liftEff(#<span class="hljs-type">WriteFile</span>(file, contents, x =&gt; x));

<span class="hljs-comment">// Our program</span>
<span class="hljs-keyword">let</span> appendStringToFile = (fileName, logLine) =&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-type">MyCustomEff</span>;

  readFileOp(fileName)
  -&gt;flatMap(logMessageOp(<span class="hljs-string">&quot;:: Logging file contents before update -&quot;</span>))
  -&gt;flatMap(contents =&gt; writeFileOp(fileName, contents<span class="hljs-operator"> ++ </span>logLine))
  -&gt;flatMap(_ =&gt; readFileOp(fileName))
  -&gt;flatMap(logMessageOp(<span class="hljs-string">&quot;:: Logging file contents after update -&quot;</span>))
};
</code></pre>
<p>You can <strong>compose any number of effects</strong> together into one for your programs!</p>
<p>And of course, nothing would work without the handler so...</p>
<pre><code class="hljs language-reasonml"><span class="hljs-keyword">let</span> handler = eff =&gt; <span class="hljs-keyword">switch</span> eff {
  | #<span class="hljs-type">LogMessage</span>(message, data, resume) =&gt; {
    <span class="hljs-type">Js</span>.log2(message, data);
    resume(data);
  }
  | #<span class="hljs-type">ReadFile</span>(fileName, resume) =&gt; readFile(fileName)-&gt;resume;
  | #<span class="hljs-type">WriteFile</span>(fileName, contents, resume) =&gt; {
    writeFile(fileName, contents);
    resume(<span class="hljs-literal">()</span>);
  };
};

<span class="hljs-keyword">let</span> result = appendStringToFile-&gt;<span class="hljs-type">MyCustomEff</span>.interpreter(handler);
</code></pre>
<hr/>
<h2>Does all of this have a name?</h2>
<p>What we just learned is a construct in functional programming called <a href="https://wiki.haskell.org/Free_structure">free algebraic structures</a>. More specifically, <code>FileEffect</code> and <code>MyCustomEff</code> are Free Monads.</p>
<p>In general, a free monad on a Functor <code>f</code> is a structure where each node represents <code>f</code>. If you understood what I just said, please explain it to me after class so I don&#x27;t look like an idiot in front of my other students.</p>
<p>In this class, we used it to <strong>fold</strong> (interpret) a data structure to generate effects.
It allowed us to decouple the composition of our effects with the effect&#x27;s behavior by creating a pure representation of our computations.</p>
<p>Free monad implementation for dealing with effects in such a way is also referred to as <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/">algebraic effects</a>.</p>
<p>To learn more about this, you could walk through the following links -</p>
<ul>
<li><a href="https://rescript-lang.org/docs/manual/latest/module#module-functions-functors">What the fuck are module functions/functors?</a></li>
<li><a href="https://medium.com/@dtinth/what-is-a-functor-dcf510b098b6">What the fuck is a Functor in category theory?</a></li>
<li><a href="https://wiki.haskell.org/All_About_Monads">What the fuck is a Monad?</a></li>
<li><a href="https://wiki.haskell.org/Free_structure">What the fuck are Free Algebraic Structures?</a></li>
<li><a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/">What the fuck are algebraic effects?</a></li>
</ul>
<hr/>
<h2>Report card</h2>
<p>Our jobs as programmers is to create as many <strong>guarantees</strong> in our code as possible.
To achieve this, we should always try to design things in a way that pushes everything we can&#x27;t guarantee to the edges.</p>
<p>This not only reduces the <strong>surface area for bugs</strong>, but also reduces the <strong>mental overhead</strong> to the person reading the code.</p>
<p>This is why we should always try to minimize the surface area of impurity in our code.</p>
<p>With free monads, we create a guarantee that our business logic is sound and we push the effects to the edge in the form of our interpreter since we may not be able to guarantee the correctness of effectful behavior.</p>
<p>Anyways, impure programs get a C for &quot;Can do better&quot;. Almost-pure programs with Free monads, get an A for &quot;Aahaaa, functional programming wins again&quot;.</p>
<p>Alright kids, get a signature on the report card from your parents. No fake signatures, John. Those squiggly lines aren&#x27;t fooling anyone.</p></div><script>function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("B:0","S:0")</script><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"meta":{"title":"Designing effects as data structures","description":"Dipping our feet into the world of effect handlers to design composition of our effects as a data-structure with free monads","published":true,"date":"2021-03-01"}},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"effect-handlers"},"buildId":"OS3xMTDMcxtkWoRrNFNqv","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>